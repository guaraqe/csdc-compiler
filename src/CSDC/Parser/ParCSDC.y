-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module CSDC.Parser.ParCSDC where
import CSDC.Parser.AbsCSDC
import CSDC.Parser.LexCSDC
import CSDC.Parser.ErrM

}

%name pCSDC CSDC
%name pOuter Outer
%name pListOuter ListOuter
%name pInner Inner
%name pListInner ListInner
%name pConstructor Constructor
%name pChoiceType ChoiceType
%name pFields Fields
%name pListString ListString
%name pTree Tree
%name pListTree ListTree
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  ',' { PT _ (TS _ 1) }
  '->' { PT _ (TS _ 2) }
  'Alias' { PT _ (TS _ 3) }
  'Committees' { PT _ (TS _ 4) }
  'DAOofDAOs' { PT _ (TS _ 5) }
  'Enum' { PT _ (TS _ 6) }
  'MultiChoice' { PT _ (TS _ 7) }
  'OneChoice' { PT _ (TS _ 8) }
  'Predefined' { PT _ (TS _ 9) }
  'Record' { PT _ (TS _ 10) }
  '{' { PT _ (TS _ 11) }
  '}' { PT _ (TS _ 12) }

L_quoted { PT _ (TL $$) }


%%

String  :: { String }  : L_quoted {  $1 }

CSDC :: { CSDC }
CSDC : '{' ListOuter '}' { CSDC.Parser.AbsCSDC.CSDC $2 }
Outer :: { Outer }
Outer : String '->' Constructor '{' ListInner '}' { CSDC.Parser.AbsCSDC.Outer $1 $3 $5 }
      | String '->' 'DAOofDAOs' '{' Fields ',' ListTree '}' { CSDC.Parser.AbsCSDC.DAOofDAOs $1 $5 $7 }
      | String '->' 'Committees' '{' ListString '}' { CSDC.Parser.AbsCSDC.Committees $1 $5 }
      | String '->' 'Alias' '{' ListString '}' { CSDC.Parser.AbsCSDC.Alias $1 $5 }
      | 'Predefined' '{' ListString '}' { CSDC.Parser.AbsCSDC.Predefined $3 }
ListOuter :: { [Outer] }
ListOuter : {- empty -} { [] }
          | Outer { (:[]) $1 }
          | Outer ',' ListOuter { (:) $1 $3 }
Inner :: { Inner }
Inner : String '->' Constructor '{' ListInner '}' { CSDC.Parser.AbsCSDC.Inner $1 $3 $5 }
      | String { CSDC.Parser.AbsCSDC.End $1 }
ListInner :: { [Inner] }
ListInner : {- empty -} { [] }
          | Inner { (:[]) $1 }
          | Inner ',' ListInner { (:) $1 $3 }
Constructor :: { Constructor }
Constructor : 'Record' { CSDC.Parser.AbsCSDC.Record }
            | ChoiceType { CSDC.Parser.AbsCSDC.Choice $1 }
ChoiceType :: { ChoiceType }
ChoiceType : 'Enum' { CSDC.Parser.AbsCSDC.Enum }
           | 'OneChoice' { CSDC.Parser.AbsCSDC.OneChoice }
           | 'MultiChoice' { CSDC.Parser.AbsCSDC.MultiChoice }
Fields :: { Fields }
Fields : '{' ListString '}' { CSDC.Parser.AbsCSDC.Fields $2 }
ListString :: { [String] }
ListString : {- empty -} { [] }
           | String { (:[]) $1 }
           | String ',' ListString { (:) $1 $3 }
Tree :: { Tree }
Tree : String '->' '{' ListTree '}' { CSDC.Parser.AbsCSDC.Branch $1 $4 }
     | String { CSDC.Parser.AbsCSDC.Leaf $1 }
ListTree :: { [Tree] }
ListTree : {- empty -} { [] }
         | Tree { (:[]) $1 }
         | Tree ',' ListTree { (:) $1 $3 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

